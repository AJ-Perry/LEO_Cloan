<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20180531040147.1"><vh>Startup</vh>
<v t="ekr.20180530013340.1"><vh>@settings</vh>
<v t="ekr.20180530013345.1"><vh>@bool run-pyflakes-on-write = True</vh></v>
</v>
<v t="ekr.20180530194308.1"><vh>@button backup</vh></v>
<v t="vitalije.20180703162528.1"><vh>@button new-tree</vh>
<v t="vitalije.20180703162528.2"><vh>from_vnode</vh></v>
<v t="vitalije.20180703162528.3"><vh>tfunc</vh></v>
<v t="vitalije.20180703162528.4"><vh>open_new_tree</vh></v>
<v t="vitalije.20180703162528.5"><vh>NewLeoTree</vh>
<v t="vitalije.20180703162528.6"><vh>draw_tree</vh></v>
<v t="vitalije.20180703162528.7"><vh>row_count</vh></v>
<v t="vitalije.20180703162528.8"><vh>paintEvent</vh></v>
<v t="vitalije.20180703162528.9"><vh>upd_size</vh></v>
<v t="vitalije.20180703162528.10"><vh>mousePressEvent</vh></v>
<v t="vitalije.20180703162528.11"><vh>click_in_pm_icon</vh>
<v t="vitalije.20180703162528.12"><vh>expand_all</vh></v>
</v>
<v t="vitalije.20180703162528.13"><vh>click_in_head</vh></v>
<v t="vitalije.20180703162528.14"><vh>click_in_icon</vh></v>
<v t="vitalije.20180703162528.15"><vh>to_leo_pos</vh></v>
</v>
</v>
<v t="vitalije.20180703162952.1"><vh>@button nt-exp-all</vh></v>
<v t="vitalije.20180703163424.1"><vh>@button nt-prom-dem</vh></v>
<v t="vitalije.20180703163059.1"><vh>@button speed-prom-dem</vh></v>
</v>
<v t="vitalije.20180514144317.3"><vh>About this file (Vitalije)</vh></v>
<v t="vitalije.20180703151212.1"><vh>@auto README.md</vh></v>
<v t="vitalije.20180703154416.1"><vh>@edit .gitignore</vh></v>
<v t="vitalije.20180510153405.1"><vh>@file leoDataModel.py</vh></v>
<v t="vitalije.20180515102254.1"><vh>@file box_images.py</vh></v>
<v t="vitalije.20180514194301.1"><vh>@file miniTkLeo.py</vh></v>
<v t="vitalije.20180624124523.1"><vh>@clean test_ltm.py</vh>
<v t="vitalije.20180624124523.2"><vh>svgexp</vh>
<v t="vitalije.20180624124523.3"><vh>p2txt</vh></v>
<v t="vitalije.20180624124523.4"><vh>g2txt</vh></v>
<v t="vitalije.20180624124523.5"><vh>row</vh></v>
<v t="vitalije.20180624124523.6"><vh>addrect</vh></v>
<v t="vitalije.20180624124523.7"><vh>addTreeG</vh></v>
<v t="vitalije.20180624124523.8"><vh>mksvg</vh></v>
<v t="vitalije.20180624124523.9"><vh>mkpic</vh></v>
<v t="vitalije.20180624124523.10"><vh>reds</vh></v>
</v>
<v t="vitalije.20180624124523.11"><vh>mk_tree_strategy</vh>
<v t="vitalije.20180624124523.12"><vh>level_size</vh></v>
<v t="vitalije.20180624124523.13"><vh>gnx_from_level</vh></v>
<v t="vitalije.20180624124523.14"><vh>mk_tree_model</vh></v>
</v>
<v t="vitalije.20180624124523.15"><vh>LTM_rule_machine</vh>
<v t="vitalije.20180624124523.16"><vh>pr_tr</vh></v>
<v t="vitalije.20180624124523.17"><vh>positions_are_unique</vh></v>
<v t="vitalije.20180624124523.18"><vh>gnxes_are_correct</vh></v>
<v t="vitalije.20180724205200.1"><vh>rules</vh>
<v t="vitalije.20180724205221.1"><vh>mark_set</vh></v>
<v t="vitalije.20180724205226.1"><vh>mark_clear</vh></v>
<v t="vitalije.20180724205229.1"><vh>clone_marked</vh></v>
<v t="vitalije.20180724205329.1"><vh>delete_marked</vh></v>
<v t="vitalije.20180724205233.1"><vh>replace_node</vh></v>
<v t="vitalije.20180724205236.1"><vh>sort_children</vh></v>
<v t="vitalije.20180724205241.1"><vh>toggle_node</vh></v>
<v t="vitalije.20180724205245.1"><vh>clone_node</vh></v>
<v t="vitalije.20180724205249.1"><vh>move_node_down</vh></v>
<v t="vitalije.20180724205254.1"><vh>move_node_up</vh></v>
<v t="vitalije.20180724205256.1"><vh>move_node_left</vh></v>
<v t="vitalije.20180724205300.1"><vh>move_node_right</vh></v>
<v t="vitalije.20180724205303.1"><vh>promote_node</vh></v>
<v t="vitalije.20180724205305.1"><vh>demote_node</vh></v>
<v t="vitalije.20180724205308.1"><vh>delete_node</vh></v>
</v>
</v>
<v t="vitalije.20180624191918.1"><vh>mkstate</vh></v>
<v t="vitalije.20180624191921.1"><vh>do_example_1</vh></v>
</v>
<v t="vitalije.20180703162227.1"><vh>@clean tmp/index.html</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20180530013340.1"></t>
<t tx="ekr.20180530013345.1">
</t>
<t tx="ekr.20180530194308.1">c.backup_helper(
    base_dir='c:/Users/edreamleo/backup',
        # 'C:/leo.repo/LeoModel',
    env_key=None, # 'LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=False,
)
</t>
<t tx="ekr.20180531040147.1"></t>
<t tx="vitalije.20180514144317.3">@language rest
@wrap

This file contains several python files:
    - leoDataModel.py
    - miniTkLeo.py
    - test_leo_data_model.py

To run test_leo_data_model.py use following command:

python test_leo_data_model.py &lt;path to Leo&gt;


Script do not depend on Leo modules, it just uses Leo
files as data for testing new LeoTreeModel class.


miniTkLeo is a minimal Tk application that shows the outline.
It allows user:

    - to change the content of any node, by typing

    - to reshape the outline by moving nodes around
      (left, right, up and down, promote/demote)

New info: May 29. 2018.
test_leo_data.py contains some tests that import all source files from
the python installed modules. Those tests rely on file paths to the
installation of python. Before executing test_leo_data check and adjust
file paths to match your instalation or any other folder you may be
interested to check.

Newest info: July 3. 2018.
This project is now on github
https://github.com/leo-editor/new-leo-model/</t>
<t tx="vitalije.20180624124523.1">@language python
'''this script should test LeoTreeModel without parPos'''
from collections import defaultdict
from leoDataModel import (LeoTreeModel, copy_ltmdata, load_leo_full, ltm_from_derived_file,
    new_gnx, parPosIter, nodes2treemodel)
import hypothesis.strategies as st
from hypothesis.stateful import (RuleBasedStateMachine, rule, initialize, invariant,
    precondition, run_state_machine_as_test)
from hypothesis import settings, PrintSettings, Verbosity, Phase
import string
import time
import sys
@others
with settings(max_examples=90, stateful_step_count=1000,
            #verbosity=Verbosity.debug,
            max_shrinks=200,
            print_blob=PrintSettings.ALWAYS,
            phases=[Phase.explicit,
                Phase.reuse, 
                Phase.generate]) as S:
    LTM_Test = LTM_rule_machine.TestCase
    LTM_Test.settings = S
if __name__ == '__main__':
    do_example_1()
</t>
<t tx="vitalije.20180624124523.10">def reds(a, b, ta, tb, inserted, deleted):
    di = 0
    res = []
    for i in range(a, b):
        if i in inserted:
            di += 1
            res.extend(((i,0),(i,1),(i,2),(i,3),(i,4)))
            continue
        elif i in deleted:
            di -= 1
            continue
        j = i + di
        r1 = row(ta, i)
        r2 = row(tb, j)
        for k in range(5):
            if r1[k] != r2[k]:
                res.append((j,k))
    return tuple(res)

</t>
<t tx="vitalije.20180624124523.11">allgnxes = [0, tuple('gnx.%04d'%i for i in range(5000))]
def ngnx():
    a, b = allgnxes
    algnxes[0] = (a + 1)%len(b)
    return b[a]

def mk_tree_strategy(min_size=30, max_size=80):
    @others
    gnxst = st.builds(ngnx)
    levsizes = st.tuples(
        st.integers(min_value=min_size, max_value=max_size), 
        st.integers(min_value=2, max_value=5)
    ).map(lambda x:tuple(level_size(x[0], i) for i in range(x[1])))
    nodepool = levsizes.map(lambda x:(x, allgnxes[1][:sum(x)]))
    return nodepool.flatmap(lambda x:gnx_from_level(x[0], x[1])).map(mk_tree_model)
</t>
<t tx="vitalije.20180624124523.12">def level_size(total, lev):
    levdivs = (5/6, 1/7, 1/10, 1/20, 1/40, 1/60, 1/80, 1/100)
    assert lev &lt; len(levdivs), 'max lev allowed %d'%(len(lendivs))
    return max(1, int(total*levdivs[lev]))

</t>
<t tx="vitalije.20180624124523.13">def gnx_from_level(lsizes, pool):
    def mkone():
        i = 0
        j = 0
        a, b = 0, lsizes[0]
        while j &lt; len(pool):
            x = pool[j]
            j += 1
            if j &gt; b:
                i += 1
                a = b
                if i &lt; len(lsizes):
                    b += lsizes[i]
                else:
                    b = len(pool)
            if i == 0:
                yield st.tuples(st.just(x), st.builds(list))
            else:
                yield st.tuples(st.just(x), st.lists(st.sampled_from(pool[:a]), min_size=1, max_size=5))
    return st.tuples(st.just(lsizes), st.tuples(*mkone()))

</t>
<t tx="vitalije.20180624124523.14">def mk_tree_model(row):
    lsizes, ns = row
    cdict = dict(ns)
    cdict['hidden-root-vnode-gnx'] = [x[0] for x in ns[-lsizes[-1]:]]
    pdict = defaultdict(list)
    heads = {'hidden-root-vnode-gnx':'root-head'}
    bodies = {'hidden-root-vnode-gnx':'root-body'}
    for x,y in ns:
        heads[x] = 'head-%d'%len(heads)
        bodies[x] = 'body-%d'%len(bodies)
    seen = set()
    def addlink(x):
        if x in seen: return
        seen.add(x)
        for y in cdict[x]:
            pdict[y].append(x)
            addlink(y)
    addlink('hidden-root-vnode-gnx')
    def viter(v, lev0):
        s = [1]
        mnode = (v, heads[v], bodies[v], lev0, s, pdict[v], cdict[v])
        yield mnode
        for ch in cdict[v]:
            for x in viter(ch, lev0 + 1):
                s[0] += 1
                yield x
    return nodes2treemodel(tuple(viter('hidden-root-vnode-gnx', 0)))

</t>
<t tx="vitalije.20180624124523.15">class LTM_rule_machine(RuleBasedStateMachine):
    def int2pos(self, pi):
        ps = self.model.data.positions
        pi1 = abs(pi) % (len(ps)-1) + 1
        if self.mdebug:print('%d -&gt; %d'%(pi, pi1))
        return ps[pi1]

    def int2int(self, pi):
        N = len(self.model.data.positions) - 1
        pi1 = 1 + (abs(pi) % N)
        if self.mdebug:print('%d -&gt; %d'%(pi, pi1))
        return pi1

    def replace_ok(self, p1, p2):
        (positions, nodes, attrs, levels, expanded, marked) = self.model.data

        p1i = abs(p1) % (len(nodes)-1) + 1
        p2i = abs(p2) % (len(nodes)-1) + 1
        if self.mdebug:print('(%d,%d)-&gt;(%d,%d)'%(p1,p2,p1i,p2i))
        sz = attrs[nodes[p1i]][4]
        if nodes[p2i] not in nodes[p1i:p1i+sz]:
            return self.model.subtree(positions[p1i]), nodes[p2i]
        else:
            return (None, None)

    def err(self):
        e = self.errnum
        self.errnum += 1
        pref = 'ltm%d'%self.examplenum
        svgexp(pref, e, self.model)

    @initialize(tr=mk_tree_strategy())
    def init(self, tr):
        self.model = tr
        self.mdebug = False
        if not hasattr(self, 'examplenum'):
            self.examplenum = 1
        else:
            self.examplenum += 1
        with open('tmp\\trdata%03d.bin'%self.examplenum, 'wb') as out:
            out.write(tr.to_bytes())

        self.errnum = 1

    @others
</t>
<t tx="vitalije.20180624124523.16">def pr_tr(self):
    td = self.model.data
    def r():
        for x, lev in zip(td.nodes, td.levels):
            if self.model.isClone(x):
                cl = 'C'
            else:
                cl = ' '
            yield '%s[%s]%s'%('- - '*lev, cl, self.model.head(x))
    print('\n'.join(r()))

</t>
<t tx="vitalije.20180624124523.17">@precondition(lambda self:hasattr(self, 'model'))
@invariant()
def positions_are_unique(self):
    n1 = len(set(self.model.data.positions))
    n2 = len(self.model.data.positions)
    if n1 != n2:self.err()
    assert n1 == n2

</t>
<t tx="vitalije.20180624124523.18">@invariant()
def gnxes_are_correct(self):
    if not hasattr(self, 'model'): return
    td = self.model.data
    zlev = zip(range(len(td.nodes)), td.nodes, td.levels)

    for i1, x, lev in zlev:
        chn = td.attrs[x][3]
        for j, i, gnx in self.model._child_iterator(i1):
            assert gnx == chn[j], 'wrong order of children %r'%((i1, x, chn, j, i, gnx),)
            assert td.levels[i] == lev + 1, 'wrong level of direct child %r'%((x,i1, i, j, gnx),)
            assert chn.count(gnx) == td.attrs[gnx][2].count(x), 'wrong number of parent links'

@invariant()
def marked_contains_no_extra_gnxes(self):
    if not hasattr(self, 'model'): return
    marked = self.model.data.marked
    attrs = self.model.data.attrs
    for x in marked:
        assert x in attrs, 'marked contains gnx which does not exist in attrs %r'%x
</t>
<t tx="vitalije.20180624124523.2">def svgexp(pref, findex, ltm):
    @others
    mkpic(pref, findex, ltm.data, None, 0, ltm.size, [], [])
    #print(findex, 'svg')

</t>
<t tx="vitalije.20180624124523.3">_p2txt = {}
for i, p in enumerate(ltm.data.positions):
    if p not in _p2txt:
        _p2txt[p] = 'P%d'%i

def p2txt(x):
    if x not in _p2txt:
        _p2txt[x] = 'P%d'%len(_p2txt)
    return _p2txt[x]
#print(','.join(_p2txt[p] for p in ltm.data.positions))

</t>
<t tx="vitalije.20180624124523.4">def mk_gnx2txt():
    _gnx2txt = {}
    N = len(ltm.data.attrs)
    n1 = 1
    if N &gt; 26:
        n1 = 2
    if N &gt; 26 * 26:
        n1 = 3
    def g2a(i):
        i, a2 = divmod(i, 26 * 26)
        a1, a0 = divmod(i, 26)
        return (chr(65 + a2) + chr(65 + a1) + chr(65 + a0))[:n1]
    for i, gnx in enumerate(sorted(ltm.data.attrs.keys())):
        _gnx2txt[gnx] = g2a(i)

    def gnx2txt(x):
        if x not in _gnx2txt:
            _gnx2txt[x] = g2a(len(_gnx2txt))
        return _gnx2txt[x]
    return gnx2txt
g2txt = mk_gnx2txt()

</t>
<t tx="vitalije.20180624124523.5">def row(tr, i):
    if len(tr.positions) &gt; i:
        x = tr.positions[i]
        gnx = tr.nodes[i]
        isMarked = gnx in tr.marked
        apos = tuple('P%d'%x for x,y in enumerate(tr.nodes) if y == gnx)
        h, b, ps, chn, sz = tr.attrs[gnx]
        achn = [g2txt(x) for x in chn]
        aps = [g2txt(x) for x in ps]
        lev = tr.levels[i]
        if lev &lt; 2:
            pp = 'P0'
        else:
            pp = 'P%d'%tr.levels.rfind(lev-1, 0, i)
        return p2txt(x), pp, lev, sz, h, apos, g2txt(gnx), achn, aps, isMarked
    return '...', '...', -1, 0, '...nista...', tuple(), '...', tuple(), tuple(), False

</t>
<t tx="vitalije.20180624124523.6">def addrect(x, y, w, h, svg):
    svg.append('&lt;svg:rect x="%f" y="%f" width="%f" height="%f" style="%s"/&gt;'%(
        x, y, w, h, 'fill:#ffffff;stroke:#000000;stroke-width:0.25'))

def addtext(x, y, t, sz, svg, isRed):
    t = t.replace('&amp;', '&amp;amp;')
    t = t.replace('&lt;', '&amp;lt;')
    t = t.replace('&gt;', '&amp;gt;')
    f = '#ff0000' if isRed else '#000000'
    svg.append(
        ('&lt;svg:text style="font-family:Verdana,Arial;font-size:%fpx;fill:%s;fill-opacity:1;text-align:center;text-anchor:middle;" '%(sz, f)) +
        ('x="%f" y="%f"&gt;'%(x+10, y)) +
        ('&lt;svg:tspan x="%f" y="%f"&gt;%s&lt;/svg:tspan&gt;&lt;/svg:text&gt;'%(x+10, y, t)))

def addtext_l(x, y, t, sz, svg, isRed):
    t = t.replace('&amp;', '&amp;amp;')
    t = t.replace('&lt;', '&amp;lt;')
    t = t.replace('&gt;', '&amp;gt;')
    f = '#ff0000' if isRed else '#000000'
    svg.append(
        ('&lt;svg:text style="font-family:Verdana,Arial;font-size:%fpx;fill:%s;fill-opacity:1;" '%(sz, f)) +
        ('x="%f" y="%f"&gt;'%(x, y)) +
        ('&lt;svg:tspan x="%f" y="%f"&gt;%s&lt;/svg:tspan&gt;&lt;/svg:text&gt;'%(x, y, t)))

</t>
<t tx="vitalije.20180624124523.7">def addTreeG(tr, a, b, x, y, res, reds):
    res.append('&lt;svg:g transform="translate(%f,%f)"&gt;'%(x, y))
    h = 10
    res.append('&lt;svg:rect x="0" y="0" width="500" height="%f" style="%s"/&gt;'%(
        (h+2)*(b - a + 1),
        'fill:#ffffee;stroke:#000000;stroke-width:0.25'))
    addtext(2, 4, 'positions', 4, res, False)
    addtext(22, 4, 'nodes', 4, res, False)
    addtext(44, 4, 'levels', 4, res, False)
    addtext(66, 4, 'size', 4, res, False)
    for i in range(a, b):
        ri = 0.5 + i - a
        p, pp, lev, sz, head, allpos, agnx, chn, pnts, isMarked = row(tr, i)
        addrect(0, ri * (h + 2), 20, h, res)
        if isMarked:
            addrect(14, ri * (h + 2) + 4, 4, h-8, res)
        addrect(22, ri * (h + 2), 20, h, res)
        addrect(44, ri * (h + 2), 20, h, res)
        addrect(66, ri * (h + 2), 20, h, res)

        addtext(0,  8+ri * (h + 2), p, 8, res, (i,0) in reds)
        addtext(22, 8+ri * (h + 2), agnx, 8, res, (i,1) in reds)
        addtext(44, 8+ri * (h + 2), str(lev), 8, res, (i,2) in reds)
        addtext(66, 8+ri * (h + 2), str(sz), 8, res, (i,3) in reds)
        addtext_l(88 + (lev * 14), 8+ri * (h + 2), head, 8, res, (i,4) in reds)
        sss = ', '.join(allpos) + '   children:[' + ' '.join(chn) + ']  / parents:[' + ' '.join(pnts) + ']'
        addtext_l(220, 8 + ri * (h + 2), sss, 6, res, False)
    res.append('&lt;/svg:g&gt;')

</t>
<t tx="vitalije.20180624124523.8">svgheader = '\n'.join(x.lstrip() for x in '''&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="400mm"
   height="205mm"
   viewBox="0 0 400 255"
   version="1.1"
   id="svg8"&gt;'''.split('\n'))
def mksvg(cont, sx, sy):
    res = [svgheader,'&lt;svg:g transform="scale(%f, %f)"&gt;'%(sx, sy), cont, '&lt;/svg:g&gt;&lt;/svg&gt;']
    return ''.join(res)

</t>
<t tx="vitalije.20180624124523.9">def mkpic(s, n, t1, t2, a, b, inserted=tuple(), deleted=tuple()):
    fname = 'tmp/%s-%d.svg'%(s, n)
    with open(fname, 'w', encoding="utf8") as out:
        svg = []
        addTreeG(t1, a, b, 0, 0, svg, [])
        if t2:
            _red = reds(a, b, t1, t2, inserted, deleted)
            addTreeG(t2, a, b, 250, 0, svg, _red)
        cont = ''.join(svg)
        sc = 250/13 / max(20, len(t1.positions))
        out.write(mksvg(cont, sc,sc))

</t>
<t tx="vitalije.20180624191918.1">def mkstate():
    ltm = LeoTreeModel.from_bytes(open('tmp/trdata001.bin', 'rb').read())
    state = LTM_rule_machine()
    state.examplenum = 1
    state.errnum = 1
    state.model = ltm
    state.mdebug = True
    return state

</t>
<t tx="vitalije.20180624191921.1">def do_example_1():
    import pdb
    state = mkstate()
    state.err() # 1
    state.promote_node(pi=0) # 1
    state.err() # 2
    state.toggle_node(pi=256) # 1
    state.err() # 3
    state.move_node_left(pi=-29091) # 4
    state.err() # 4
    state.move_node_left(pi=-8545) # 2
    state.err() # 5
    state.move_node_up(pi=66) # 3
    state.err() # 6
    state.clone_node(pi=-3774) # 7
    state.err() # 7
    state.clone_marked(pi=29926) # 2
    state.err() # 8
    state.clone_marked(pi=-4579) # 8
    state.err() # 9
    state.mark_clear(pi=-29222) # 9
    state.err() # 10
    state.move_node_down(pi=-10) # 2
    state.err() # 11
    state.clone_node(pi=6352) # 8
    state.err() # 12
    state.demote_node(pi=-24) # 5
    state.err() # 13
    state.mark_clear(pi=61) # 2
    state.err() # 14
    state.mark_clear(pi=-31100) # 1
    state.err() # 15
    state.promote_node(pi=27354) # 5
    state.err() # 16
    state.mark_set(pi=13875) # 6
    state.err() # 17
    state.mark_clear(pi=21021) # 2
    state.err() # 18
    state.replace_node(p1=-122, p2=72121929359983009) # (3,10)
    state.err() # 19
    state.demote_node(pi=-6) # 7
    state.err() # 20
    state.replace_node(p1=2907, p2=120) # (8,1)
    state.err()

</t>
<t tx="vitalije.20180703162227.1">&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf8"&gt;
    &lt;title&gt;Leo Data Model - inside view&lt;/title&gt;
&lt;/head&gt;
&lt;body style="background:#113311"&gt;
&lt;p&gt;&lt;label&gt;Pic:&lt;/label&gt;&lt;input type="range" min="0" max="500" id="selimg"&gt;&lt;/p&gt;
    &lt;img width="100%"
         id="imgview" alt="there are no more images in this experiment" src="sl-0.svg"/&gt;
&lt;script type="text/javascript"&gt;
var chfunc = function(){
    var v = document.getElementById('selimg').value;
    document.querySelector('p&gt;label').innerHTML = 'Pic:'+v;
    var h = (location.hash || '#sl').substring(1);
    document.getElementById('imgview').src = h + '-'+v+'.svg#e'+Math.random();
};
document.getElementById('selimg').addEventListener('change', chfunc);
window.addEventListener('load', function(){
    console.log('document loaded');
    chfunc();
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="vitalije.20180703162528.1">@language python
import timeit
from leo.core.leoQt import QtCore, QtWidgets, QtConst, QtGui
from leo.plugins.nested_splitter import NestedSplitter
@others
open_new_tree()
g.es('ok')</t>
<t tx="vitalije.20180703162528.10">def mousePressEvent(self, ev):
    x = ev.x()
    y = ev.y()
    HR = self.HR
    LW = 2 * HR
    row = (y - 2)//HR
    if row &lt; len(self.vpositions):
        p, gnx, x0 = self.vpositions[row]
    else:
        g.es('click outside')
        return
    if abs(x - x0) &lt; HR / 2:
        self.click_in_pm_icon(p)
    elif abs(x - x0 - 20 - LW/2) &lt; LW / 2:
        self.click_in_icon(p)
    elif x &gt;= x0 + 24 + LW:
        self.click_in_head(p, gnx)</t>
<t tx="vitalije.20180703162528.11">def click_in_pm_icon(self, p):
    self.ltm.toggle(p)
    self.ltm.invalidate_visual()
    if not self.ltm.selectedPosition in self.ltm.visible_positions:
        self.ltm.selectedPosition = p
    self.upd_size()
    self.update()

</t>
<t tx="vitalije.20180703162528.12">def expand_all(self):
    self.ltm.expand_all()
    self.ltm.invalidate_visual()
    self.upd_size()
    self.update()</t>
<t tx="vitalije.20180703162528.13">def click_in_head(self, p, gnx):
    g.es('click on head:', self.ltm.head(gnx))
    self.click_in_icon(p)</t>
<t tx="vitalije.20180703162528.14">def click_in_icon(self, p):
    self.ltm.selectedPosition = p
    self.update()
    self.c.selectPosition(self.to_leo_pos(p))</t>
<t tx="vitalije.20180703162528.15">def to_leo_pos(self, p):
    try:
        return leoDataModel.to_leo_pos(self.ltm.data, p, self.c)
    except Exception:
        g.es_exception(True, self.c)</t>
<t tx="vitalije.20180703162528.2">import leoDataModel
import imp
imp.reload(leoDataModel)
def from_vnode():
    return leoDataModel.vnode2treemodel(c.hiddenRootNode)</t>
<t tx="vitalije.20180703162528.3">def tfunc(f, num=100):
    t1 = timeit.timeit(f, number=num)*1000/num
    g.es('%s Avg:%.1fms'%(f.__name__, t1))</t>
<t tx="vitalije.20180703162528.4">def open_new_tree():
    w = c.frame.body.widget
    while not isinstance(w, NestedSplitter):
        w = w.parent()
    qsa = QtWidgets.QScrollArea()
    w.insert(-1, qsa)
    c._new_leo_tree = NewLeoTree(c, qsa)
    c._new_leo_tree.resize(1000, w.height())
</t>
<t tx="vitalije.20180703162528.5">class NewLeoTree(QtWidgets.QFrame):
    def __init__(self, c, qsa):
        self.HR = 24
        self.MAX_W = 1000
        self.ltm = leoDataModel.vnode2treemodel(c.hiddenRootNode)
        self.vpositions = list(self.ltm.visible_positions)
        QtWidgets.QFrame.__init__(self)
        self.qsa = qsa
        self.qsa.verticalScrollBar().valueChanged.connect(self.vbchanged)
        self.c = c
        qsa.setWidget(self)
        self.setAttribute(QtConst.WA_DeleteOnClose)
        self.icons = [g.app.gui.getImageImage('box%02d.png'%i) for i in range(16)]
        self.plusic = g.app.gui.getImageImage('plusnode.gif')
        self.minusic = g.app.gui.getImageImage('minusnode.gif')

    @others
    def vbchanged(self, ev):
        self.move(0,0)</t>
<t tx="vitalije.20180703162528.6">def draw_tree(self, painter, ltm):
    HR = self.HR
    self.top_index =  self.qsa.verticalScrollBar().value()
    Y0 = self.geometry().y()
    LW = 2 * HR
    W = self.width()
    count = self.row_count(HR)
    pen_1 = painter.pen()
    pen_2 = QtGui.QColor('#000000')
    f = painter.font()
    f.setPixelSize(HR-4)
    painter.setFont(f)
    fm = painter.fontMetrics()
    vpositions = self.vpositions
    del vpositions[:]
    MW = 100
    for j, dd in enumerate(ltm.display_items(self.top_index, count)):
        p, gnx, h, lev, pm, iconVal, sel = dd
        x = lev * LW - 20
        y = j * HR + 2 - Y0
        vpositions.append((p, gnx, x))
        MW = max(MW, fm.boundingRect(h).width() + x + 24 + LW)
        if sel:
            painter.fillRect(0, y, W, HR + 2, QtGui.QColor('#77cccc'))
            painter.setPen(pen_2)
            painter.drawText(x + 24 + LW, y + HR - 4, h)
            painter.setPen(pen_1)
        else:
            painter.drawText(x + 24 + LW, y + HR - 4, h)
        if pm != 'none':
            pmicon = self.plusic if pm == 'plus' else self.minusic
            painter.drawPixmap(x, y + HR//2 - pmicon.height()//2, pmicon)
        painter.drawPixmap(x + 20, y, LW, HR, self.icons[iconVal])
    self.MAX_W = MW
    if self.MAX_W &gt; self.width():
        self.upd_width()

def upd_width(self):
    self.resize(self.MAX_W, self.qsa.height())
    self.upd_size()
    self.update()</t>
<t tx="vitalije.20180703162528.7">def row_count(self, h):
    return max(1, self.height() // h)</t>
<t tx="vitalije.20180703162528.8">def paintEvent(self, event):
    '''
    Enhance QFrame.paintEvent.
    '''
    painter = QtGui.QPainter(self)
    try:
        self.draw_tree(painter, self.ltm)
        dtr = painter.combinedTransform()
        self.dtr = dtr.dx(), dtr.dy()
    except Exception:
        if not hasattr(self, 'error_reported'):
            g.es_exception(True, c)
            self.error_reported = True
</t>
<t tx="vitalije.20180703162528.9">def upd_size(self):
    H1 = self.height() // self.HR
    H = len(self.ltm.visible_positions)
    vb = self.qsa.verticalScrollBar()
    vb.setRange(0, H - H1)
    vb.setPageStep(H1)
    vb.setSingleStep(1)</t>
<t tx="vitalije.20180703162952.1">c._new_leo_tree.expand_all()</t>
<t tx="vitalije.20180703163059.1">import timeit
pp = p.copy()
def f_exp():
    c.expandAllHeadlines()
    c.selectPosition(pp.copy())
def f_prom_dem():
    c.selectPosition(pp.copy())
    c.demote(pp.copy())
    c.promote(pp.copy())
def test_f(f, s, num):
    t1 = timeit.timeit(f, number=num)*1000/num
    g.es(s, 'Avg: %.1fms'%t1)
test_f(f_exp, 'expandAllHeadlines', 1)
test_f(f_prom_dem, 'promote/demote', 5)
</t>
<t tx="vitalije.20180703163424.1">w = c._new_leo_tree
import timeit
def f():
    p = w.ltm.selectedPosition
    w.ltm.promote(p)
    w.repaint()
    w.ltm.promote_children(p)
    w.repaint()
t1 = timeit.timeit(f, number=100)*1000/100
g.es('Avg: %.1fms'%t1)
</t>
<t tx="vitalije.20180724205200.1"></t>
<t tx="vitalije.20180724205221.1">@rule(pi=st.integers())
def mark_set(self, pi):
    pos = self.int2pos(pi)
    self.model.set_mark(pos)

</t>
<t tx="vitalije.20180724205226.1">@rule(pi=st.integers())
def mark_clear(self, pi):
    pos = self.int2pos(pi)
    self.model.clear_mark(pos)

</t>
<t tx="vitalije.20180724205229.1">@precondition(lambda self:self.model.size &lt; 300)
@rule(pi=st.integers())
def clone_marked(self, pi):
    pos = self.int2pos(pi)
    self.model.selectedPosition = pos
    self.model.clone_marked(new_gnx)

</t>
<t tx="vitalije.20180724205233.1">@rule(p1=st.integers(), p2=st.integers())
def replace_node(self, p1, p2):
    tr, gnx = self.replace_ok(p1, p2)
    if tr:
        tr.change_gnx(tr.data.nodes[0], gnx)
        self.model.replace_node(tr)

</t>
<t tx="vitalije.20180724205236.1">@rule(pi=st.integers())
def sort_children(self, pi):
    self.model.sort_children(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205241.1">@rule(pi=st.integers())
def toggle_node(self, pi):
    self.model.toggle(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205245.1">@precondition(lambda self:self.model.size &lt; 300)
@rule(pi=st.integers())
def clone_node(self, pi):
    self.model.clone_node_i(self.int2int(pi))

</t>
<t tx="vitalije.20180724205249.1">@rule(pi=st.integers())
def move_node_down(self, pi):
    self.model.move_node_down(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205254.1">@rule(pi=st.integers())
def move_node_up(self, pi):
    self.model.move_node_up(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205256.1">@rule(pi=st.integers())
def move_node_left(self, pi):
    self.model.dedent_node(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205300.1">@rule(pi=st.integers())
def move_node_right(self, pi):
    self.model.indent_node(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205303.1">@rule(pi=st.integers())
def promote_node(self, pi):
    self.model.promote(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205305.1">@rule(pi=st.integers())
def demote_node(self, pi):
    self.model.promote_children(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205308.1">@rule(pi=st.integers())
def delete_node(self, pi):
    self.model.delete_node(self.int2pos(pi))

</t>
<t tx="vitalije.20180724205329.1">@precondition(lambda self:self.model.size &lt; 300)
@rule(pi=st.integers())
def delete_marked(self, pi):
    pos = self.int2pos(pi)
    self.model.selectedPosition = pos
    self.model.clone_marked(new_gnx)

</t>
</tnodes>
</leo_file>
